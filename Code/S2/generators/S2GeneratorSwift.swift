//
// Created by Alexander Babaev on 08.02.16.
// Copyright (c) 2016 LonelyBytes. All rights reserved.
//

import Foundation

#if os(iOS)
    import KTVKit
#endif

private extension KTVObject {
    func hasProperties(propertyNames:[String]) -> Bool {
        for name in propertyNames {
            if properties[name] == nil {
                return false
            }
        }

        return true
    }
}

private extension KTVValue {
    var doubleValue:Double {
        var result:Double = 0.0

        if case .int(let value) = self {
            result = Double(value)
        } else if case .double(let value) = self {
            result = value
        } else if case .string(let value) = self {
            if let doubleValue = Double(value) {
                result = doubleValue
            }
        }

        return result
    }
}

private extension String {
    func capitalizeFirstLetter() -> String {
        if isEmpty {
            return self
        } else {
            return substringToIndex(startIndex.successor()).uppercaseString + substringFromIndex(startIndex.successor())
        }
    }
}

class S2GeneratorSwift: S2Generator {
    private let _needObjCCompatibility:Bool

    private var _rootObject = KTVObject()
    private var _usedClassNamesForObjC:[String] = []

    init(withObjCCompatibility:Bool) {
        _needObjCCompatibility = withObjCCompatibility
    }

    func generateToFile(path:String, fromObject ktvObject:KTVObject, rootClassName:String, needS2Import:Bool, needSingleton:Bool) throws {
        //ToDo: this is why class is not thread-safe
        _rootObject = ktvObject

        var fileString = fileHeader(rootClassName, needS2Import:needS2Import, needSingleton:needSingleton)
        let (structString, _) = try getStructForObject(_rootObject, className:rootClassName, isRootClass:true)
        fileString += structString

        try fileString.writeToFile(path, atomically:true, encoding:NSUTF8StringEncoding)

        _rootObject = KTVObject()
        _usedClassNamesForObjC = []
    }

    private func fileHeader(rootClassName:String, needS2Import:Bool, needSingleton:Bool) -> String {
        return "// AUTOGENERATED FILE\n" +
               "// Do not edit manually please\n" +
               "\n" +
               "import Foundation\n" +
               "import UIKit\n" +
               (needS2Import ? "import S2Kit\n" : "") +
               "\n" +
               (needSingleton ? "let S2 = \(rootClassName)()\n" : "") +
               "\n"
    }

    private func getStructForObject(object:KTVObject, className:String, isRootClass:Bool) throws -> (String, String) {
        let classOrStruct = _needObjCCompatibility ? "@objc public class" : "public struct"
        let parentClass = _needObjCCompatibility ? "S2ObjectForObjC" : "S2Object"

        var classNameForObjC = className
        if _needObjCCompatibility {
            var index = 2
            while _usedClassNamesForObjC.contains(classNameForObjC) {
                classNameForObjC = "\(className)_\(index)"
                index += 1
            }

            _usedClassNamesForObjC.append(classNameForObjC)
        }

        var result = "\(classOrStruct) \(classNameForObjC): \(parentClass) " +
                     "{\n";
        if isRootClass {
            result += "    private static let _rootStyle = S2\n"
            if isRootClass && _needObjCCompatibility {
                result += "    public static func rootStyle() -> \(classNameForObjC) { return S2 } // because ObjC can not see the global variable\n"
            }
            result += "\n"
        }

        let simpleValues = try processPropertiesInObject(object, showSimpleValues:true, showObjects:false, showArrays:false)
        var arrayValues = try processPropertiesInObject(object, showSimpleValues:false, showObjects:false, showArrays:true)
        var objectValues = try processPropertiesInObject(object, showSimpleValues:false, showObjects:true, showArrays:false)

        if simpleValues.isEmpty && arrayValues.isEmpty && objectValues.hasPrefix("\n") {
            objectValues = objectValues.substringFromIndex(objectValues.startIndex.successor())
        }

        if simpleValues.isEmpty && arrayValues.hasPrefix("\n") {
            arrayValues = arrayValues.substringFromIndex(arrayValues.startIndex.successor())
        }

        result += simpleValues
        result += arrayValues
        result += objectValues

        result += "}\n"

        return (result, classNameForObjC)
    }

    private func processPropertiesInObject(object:KTVObject, showSimpleValues:Bool, showObjects:Bool, showArrays:Bool) throws -> String {
        var result = ""

        for name in object.propertyNamesInAddedOrder {
            if let propertyValue = object.properties[name] {
                if name.hasPrefix("@") || name.hasPrefix("//") {
                    //ToDo: log a warning
                    continue
                }

                if name.hasPrefix("new") {
                    //ToDo: check all the bad names
                    throw S2GeneratorErrors.WrongPropertyPrefix("new")
                }

                var needProcess = false
                switch propertyValue {
                    case .nilValue, .bool(_), .string(_), .int(_), .double(_), .color(_), .reference(_):
                        needProcess = showSimpleValues
                    case .object(let type, let object):
                        if objectIsFont(object, type:type, name:name) || objectIsTextAttributes(object, type:type, name:name) {
                            needProcess = showSimpleValues
                        } else {
                            needProcess = showObjects
                        }
                    case .array(let type, let values):
                        if arrayIsPoint(values, type:type, name:name) || arrayIsRect(values, type:type, name:name) || arrayIsEdgeInsets(values, type:type, name:name) {
                            needProcess = showSimpleValues
                        } else {
                            needProcess = showArrays
                        }
                }

                if needProcess {
                    result += try serializeValue(propertyValue, withName:name)
                }
            }
        }

        return result
    }

    private func serializeValue(propertyValue:KTVValue, withName name:String) throws -> String {
        var result = ""

        switch propertyValue {
            case .nilValue:
                result = "    let \(name):AnyObject? = nil\n"
            case .bool(let value):
                result = "    let \(name):Bool = \(value)\n"
            case .string(let value):
                if (name == "color" || name.hasSuffix("Color")) && value == "clear" {
                    result = "    let \(name):UIColor = UIColor.clearColor()\n"
                } else {
                    result = "    let \(name):String = \"\(escapeString(value))\"\n"
                }
            case .int(let value):
                result = "    let \(name):Int = Int(\(value))\n"
            case .double(let value):
                result = "    let \(name):CGFloat = CGFloat(\(value))\n"

            case .color(let value):
                result = "    let \(name):UIColor = \(colorValue(value))\n"

            case .object(let type, let object):
                result = try serializeObjectValue(object, type:type, name:name)
            case .array(let type, let values):
                result = try serializeArrayValue(values, type:type, name:name)

            case .reference(let link):
                if link.hasPrefix("~") {
                    let functionResultValue = try _rootObject.findObjectByReference(link, functionResolver: S2Styler.functionResolver)
                    switch functionResultValue {
                        case .color(let hexColor):
                            result = "    let \(name) = \(colorValue(hexColor))\n"
                        default:
                            break
                    }
                } else {
                    result = "    let \(name) = \(referenceProperty(propertyValue))\n"
                }
        }

        return result
    }

    private func referenceProperty(propertyValue:KTVValue) -> String {
        var result = ""

        if case .reference(let referenceLink) = propertyValue {
            var reference = referenceLink
            if reference.hasPrefix("@") {
                reference = reference.substringFromIndex(reference.startIndex.successor())
                result = "_rootStyle.\(reference)"
            }
        }

        return result
    }

    private func serializeArrayValue(values:[KTVValue], type:String, name:String) throws -> String {
        var className = ""
        var value = ""

        if arrayIsPoint(values, type:type, name:name) {
            className = ""
            value = pointValue(values)
        } else if arrayIsEdgeInsets(values, type:type, name:name) {
            className = ""
            value = edgeInsetsValue(values)
        } else if arrayIsRect(values, type:type, name:name) {
            className = ""
            value = rectValue(values)
        } else {
            className = ":[AnyObject?]"
            value += "["

            var isFirst = true
            for arrayValue_ in values {
                if !isFirst {
                    value += ", "
                }

                var arrayValue = arrayValue_

                if case .reference(let referenceLink) = arrayValue {
                    arrayValue = try _rootObject.findObjectByReference(referenceLink)
                }

                switch arrayValue {
                    case .nilValue:
                        value += "nil"
                    case .bool(let value_):
                        value += "\(value_)"
                        if isFirst{
                            className = ":[Bool]"
                        }
                    case .string(let value_):
                        value += "\"\(escapeString(value_))\""
                        if isFirst{
                            className = ":[String]"
                        }
                    case .int(let value_):
                        value += "Int(\(value_))"
                        if isFirst{
                            className = ":[Int]"
                        }
                    case .double(let value_):
                        value += "CGFloat(\(value_))"
                        if isFirst{
                            className = ":[CGFloat]"
                        }

                    case .color(let value_):
                        value += "\(colorValue(value_))"
                        if isFirst{
                            className = ":[UIColor]"
                        }

                    default:
                        throw S2GeneratorErrors.ArrayCanNotContainObjectsOrArrays
                }

                if isFirst{
                    isFirst = false
                }
            }

            value += "]"
        }

        return "    let \(name)\(className) = \(value)\n"
    }

    private func serializeObjectValue(object:KTVObject, type:String, name:String) throws -> String {
        var structDefinition = "    "

        var className = ""
        var value = ""

        if objectIsFont(object, type:type, name:name) {
            className = ":UIFont"
            value = try fontValue(object)
        } else if objectIsTextAttributes(object, type:type, name:name) {
            className = ":[String:AnyObject]"
            value = try textAttributesValue(object).stringByReplacingOccurrencesOfString("\n", withString:"\n    ")
        } else {
            className = name.capitalizeFirstLetter()
            let (structString, classNameForObjC) = try getStructForObject(object, className:className, isRootClass:false)
            className = ":" + classNameForObjC
            structDefinition = "\n    " + (structString.stringByReplacingOccurrencesOfString("\n", withString:"\n    "))
            value = "\(classNameForObjC)()"
        }

        return "\(structDefinition)let \(name)\(className) = \(value)\n"
    }

// MARK - Data Validators

    private func objectIsFont(object:KTVObject, type:String, name:String) -> Bool {
        var result = false

        if object.hasProperties(["name", "size"]) {
            result = true
        } else if object.hasProperties(["name"]) && (name.hasSuffix("Font") || name == "font") {
            result = true
        }

        return result
    }

    private func objectIsTextAttributes(object:KTVObject, type:String, name:String) -> Bool {
        var result = false

        if object.hasProperties(["font", "color"]) &&
                (type.lowercaseString.hasSuffix("textattributes") ||
                 name.lowercaseString.hasSuffix("textattributes")) {
            result = true
        }

        return result
    }

    private func arrayIsPoint(values:[KTVValue], type:String, name:String) -> Bool {
        var result = false

        if values.count == 2 {
            if case .double(_) = values[0] {
                result = true
            } else if case .int(_) = values[0] {
                result = true
            }
        }

        return result
    }

    private func arrayIsEdgeInsets(values:[KTVValue], type:String, name:String) -> Bool {
        var result = false

        if values.count == 4 &&
                (type.lowercaseString.hasSuffix("edgeinsets") || type.lowercaseString.hasSuffix("margins") ||
                 name.lowercaseString.hasSuffix("edgeinsets") || name.lowercaseString.hasSuffix("margins")) {
            if case .double(_) = values[0] {
                result = true
            } else if case .int(_) = values[0] {
                result = true
            }
        }

        return result
    }

    private func arrayIsRect(values:[KTVValue], type:String, name:String) -> Bool {
        var result = false

        if values.count == 4 &&
                (type.lowercaseString.hasSuffix("rect") ||
                 name.lowercaseString.hasSuffix("rect")) {
            if case .double(_) = values[0] {
                result = true
            } else if case .int(_) = values[0] {
                result = true
            }
        }

        return result
    }

// MARK â€” Data serializers

    private func colorValue(hexString:String) -> String {
        let (red, green, blue, alpha) = ColorUtils.colorFromHex(hexString)
        return "UIColor(colorLiteralRed:Float(\(red)), green:Float(\(green)), blue:Float(\(blue)), alpha:Float(\(alpha)))"
    }

    private func fontValue(object:KTVObject) throws -> String {
        let nameResult = try object.stringOrReference(key:"name", defaultValue:"system", resolveReferences:false)
        let sizeResult = try object.doubleOrReference(key:"size", defaultValue:14.0, resolveReferences:false)
        var weightConstructor = ""

        let weightString = try object.stringOrReference(key:"weight", defaultValue:"regular").value
        var weight = "UIFontWeightRegular"
        switch weightString.lowercaseString {
            case "ultralight":
                weight = "UIFontWeightUltraLight"
            case "thin":
                weight = "UIFontWeightThin"
            case "light":
                weight = "UIFontWeightLight"
            case "regular":
                weight = "UIFontWeightRegular"
            case "medium":
                weight = "UIFontWeightMedium"
            case "semibold":
                weight = "UIFontWeightSemibold"
            case "bold":
                weight = "UIFontWeightBold"
            case "heavy":
                weight = "UIFontWeightHeavy"
            case "black":
                weight = "UIFontWeightBlack"
            default:
                weight = "UIFontWeightRegular"
        }

        if weight != "UIFontWeightRegular" {
            weightConstructor = ".fontDescriptorByAddingAttributes([UIFontWeightTrait:\(weight)])"
        }

        var name = "\"\(nameResult.value)\""
        if let nameReference = nameResult.reference {
            name = "_rootStyle." + nameReference
        }

        var size = "\(sizeResult.value)"
        if let sizeReference = sizeResult.reference {
            size = "_rootStyle." + sizeReference
        }

        return "UIFont(descriptor:UIFontDescriptor(name:\(name), size:\(size))\(weightConstructor), size:\(size))"
    }

    private func textAttributesValue(object:KTVObject) throws -> String {
        var results:[String] = []
        var paragraphAttributes:[String] = []

        for name in object.propertyNamesInAddedOrder {
            if let value = object.properties[name] {
                switch name {
                    case "font":
                        if case .object(_, let object) = value {
                            try results.append("    NSFontAttributeName: " + fontValue(object))
                        } else if case .reference(_) = value {
                            results.append("    NSFontAttributeName: " + referenceProperty(value))
                        } else {
                            throw S2GeneratorErrors.BadFontObject
                        }
                    case "color", "foregroundColor":
                        if case .color(let hexColor) = value {
                            results.append("    NSForegroundColorAttributeName: " + colorValue(hexColor))
                        } else if case .reference(_) = value {
                            results.append("    NSFontAttributeName: " + referenceProperty(value))
                        } else {
                            throw S2GeneratorErrors.BadColorObject
                        }
                    case "lineHeight":
                        paragraphAttributes.append("        \"\(name)\": CGFloat(\(value.doubleValue))")
                    case "paragraphSpacing":
                        paragraphAttributes.append("        \"\(name)\": CGFloat(\(value.doubleValue))")
                    case "paragraphSpacingBefore":
                        paragraphAttributes.append("        \"\(name)\": CGFloat(\(value.doubleValue))")
                    case "alignment":
                        if case .string(let alignment) = value {
                            switch alignment {
                                case "center", "Center", "NSTextAlignmentCenter":
                                    paragraphAttributes.append("        \"\(name)\": NSTextAlignment.Center.rawValue")
                                case "left", "Left", "NSTextAlignmentLeft":
                                    paragraphAttributes.append("        \"\(name)\": NSTextAlignment.Left.rawValue")
                                case "right", "Right", "NSTextAlignmentRight":
                                    paragraphAttributes.append("        \"\(name)\": NSTextAlignment.Right.rawValue")
                                case "justify", "justified", "Justify", "Justified", "NSTextAlignmentJustified":
                                    paragraphAttributes.append("        \"\(name)\": NSTextAlignment.Justified.rawValue")
                                default:
                                    paragraphAttributes.append("        \"\(name)\": NSTextAlignment.Natural.rawValue")
                            }
                        }
                    case "lineBreakMode":
                        if case .string(let wrapping) = value {
                            switch wrapping {
                                case "wordWrapping", "NSLineBreakModeByWordWrapping":
                                    paragraphAttributes.append("        \"\(name)\": NSLineBreakMode.ByWordWrapping.rawValue")
                                case "charWrapping", "NSLineBreakModeByCharWrapping":
                                    paragraphAttributes.append("        \"\(name)\": NSLineBreakMode.ByCharWrapping.rawValue")
                                case "clipping", "NSLineBreakModeByClipping":
                                    paragraphAttributes.append("        \"\(name)\": NSLineBreakMode.ByClipping.rawValue")
                                case "truncatingHead", "NSLineBreakModeByTruncatingHead":
                                    paragraphAttributes.append("        \"\(name)\": NSLineBreakMode.ByTruncatingHead.rawValue")
                                case "truncatingMiddle", "NSLineBreakModeByTruncatingMiddle":
                                    paragraphAttributes.append("        \"\(name)\": NSLineBreakMode.ByTruncatingMiddle.rawValue")
                                case "truncatingTail", "NSLineBreakModeByTruncatingTail":
                                    paragraphAttributes.append("        \"\(name)\": NSLineBreakMode.ByTruncatingTail.rawValue")
                                default:
                                    paragraphAttributes.append("        \"\(name)\": NSLineBreakMode.ByTruncatingTail.rawValue")
                            }
                        }
                    default:
                        print("!!!!!!!!!!!!!!! Can't parse text attribute: \(name)")
                }
            }
        }

        if !paragraphAttributes.isEmpty {
            results.append("    NSParagraphStyleAttributeName: S2Styler.buildParagraphStyle([\n" + paragraphAttributes.joinWithSeparator(",\n") + "\n    ])")
        }

        return "[\n" + results.joinWithSeparator(",\n") + "\n]\n"
    }

    private func pointValue(values:[KTVValue]) -> String {
        let x = values[0].doubleValue
        let y = values[1].doubleValue
        return "CGPoint(x:\(x), y:\(y))"
    }

    private func edgeInsetsValue(values:[KTVValue]) -> String {
        let top = values[0].doubleValue
        let left = values[1].doubleValue
        let bottom = values[2].doubleValue
        let right = values[3].doubleValue
        return "UIEdgeInsets(top:\(top), left:\(left), bottom:\(bottom), right:\(right))"
    }

    private func rectValue(values:[KTVValue]) -> String {
        let x = values[0].doubleValue
        let y = values[1].doubleValue
        let width = values[2].doubleValue
        let height = values[3].doubleValue
        return "CGRect(x:\(x), y:\(y), width:\(width), height:\(height))"
    }

// MARK - Helpers

    private func escapeString(string:String) -> String {
        var result = string.stringByReplacingOccurrencesOfString("\"", withString:"\\\"")
        result = result.stringByReplacingOccurrencesOfString("\n", withString:"\\n")
        result = result.stringByReplacingOccurrencesOfString("\r", withString:"\\r")

        return result
    }
}
