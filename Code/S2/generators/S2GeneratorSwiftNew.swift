//
// Created by Alexander Babaev on 15/06/2016.
// Copyright (c) 2016 LonelyBytes. All rights reserved.
//

import Foundation

private extension String {
    func capitalizeFirstLetter() -> String {
        if isEmpty {
            return self
        } else {
            return substringToIndex(startIndex.successor()).uppercaseString + substringFromIndex(startIndex.successor())
        }
    }
}

class S2GeneratorSwiftNew: S2Generator {
    func generateToFile(path: String, fromObject: KTVObject, rootClassName: String, needS2Import: Bool, needSingleton: Bool) throws {
        let classProperties = try objectPropertyFor(name: rootClassName, type: "", object: fromObject, fullKey: "", rootKtv: fromObject)

        let file =
        "// AUTOGENERATED FILE\n" +
        "// Do not edit manually please\n" +
        "\n" +
        "import Foundation\n" +
        "import UIKit\n" +
        "import KTVKit\n" +
        "import S2Kit\n" +
        "\n\n" +
        classProperties

        try file.writeToFile(path, atomically: true, encoding: NSUTF8StringEncoding)
    }

    func propertyFor(name name: String, value: KTVValue, fullKey: String, rootKtv: KTVObject) throws -> String {
        var result = ""

        NSLog("%@", fullKey)

        switch value {
            case .nilValue:
                result = "lazy var \(name):AnyObject? = nil"
            case .bool(_):
                result = "lazy var \(name):Bool = self.bool(\"\(fullKey)\")"
            case .string(_):
                result = "lazy var \(name):String = self.string(\"\(fullKey)\")"
            case .int(_):
                result = "lazy var \(name):Int = self.int(\"\(fullKey)\")"
            case .double(_):
                result = "lazy var \(name):Double = self.double(\"\(fullKey)\")"

            case .color(_):
                result = "lazy var \(name):UIColor = self.color(\"\(fullKey)\")"

            case .reference(let referenceKey):
                let value = try rootKtv.findObjectByReference(referenceKey)
                result = try propertyFor(name: name, value: value, fullKey: fullKey, rootKtv: rootKtv)

            case .object(let type, let object):
                if type == "font" {
                    result = "lazy var \(name):UIFont = self.font(\"\(fullKey)\")"
                } else if type == "textAttributes" {
                    result = "lazy var \(name):[String:AnyObject] = self.textAttributes(\"\(fullKey)\")"
                } else {
                    let classDefinition = try objectPropertyFor(name: name, type: type, object: object, fullKey: fullKey, rootKtv: rootKtv)
                    let className = name.capitalizeFirstLetter()
                    result = "\nlazy var \(name):\(className) = \(className)(ktv:self.ktv)\n\(classDefinition)\n"
                }

            case .array(let type, _):
                if type == "point" {
                    result = "lazy var \(name):CGPoint = self.point(\"\(fullKey)\")"
                } else if type == "rect" {
                    result = "lazy var \(name):CGRect = self.rect(\"\(fullKey)\")"
                } else if type == "insets" {
                    result = "lazy var \(name):UIEdgeInsets = self.edgeInsets(\"\(fullKey)\")"
                } else {
                    throw S2GeneratorErrors.UnsupportedValueType
                }

//            default:
//                throw S2GeneratorErrors.UnknownValueType
        }

        return result
    }

    func objectPropertyFor(name name: String, type: String, object: KTVObject, fullKey: String, rootKtv: KTVObject) throws -> String {
        let properties = try object.properties.map {
            (key: String, value: KTVValue) -> String in

            let propertyFullKey = fullKey.isEmpty ? key : "\(fullKey).\(key)"

            return try self.propertyFor(name: key, value: value, fullKey: propertyFullKey, rootKtv: rootKtv).stringByReplacingOccurrencesOfString("\n", withString: "\n    ")
        }

        var propertiesString: String = properties.reduce("") {
            if $0.isEmpty {
                if $1.hasPrefix("\n") {
                    return "    " + $1.stringByReplacingOccurrencesOfString("^\\s+", withString: "", options: [.RegularExpressionSearch], range: nil)
                } else {
                    return "    " + $1
                }
            } else {
                return $0 + "\n    " + $1
            }
        }

        if propertiesString.hasSuffix("\n    ") {
            propertiesString = propertiesString.stringByReplacingOccurrencesOfString("\\s+$", withString: "", options: [.RegularExpressionSearch], range: nil)
        }

        let applyer = try createApplyerCode(type: type, object: object, fullKey: fullKey, rootKtv: rootKtv)

        return "public struct \(name.capitalizeFirstLetter()): StyleObject {\n" +
                    propertiesString + "\n" +
               "\n" +
               "    public let ktv:KTVObject\n" +
               "    init(ktv:KTVObject) { self.ktv = ktv }\n" +
                    applyer +
               "}"
    }

    func arrayPropertyFor(name name: String, type: String, arrayValues: KTVObject, fullKey: String, rootKtv: KTVObject) throws -> String {
        return ""
    }
}

private extension S2GeneratorSwiftNew {
    func createApplyerCode(type type: String, object: KTVObject, fullKey: String, rootKtv: KTVObject) throws -> String {
        if type == "UILabel" || type == "UIButton" || type == "UITextField" || type == "UITextView" {
            let applyedProperties = object.properties.flatMap {
                (key: String, value: KTVValue) -> String? in

                return "        object.\(key) = self.\(key)"

//                let propertyFullKey = fullKey.isEmpty ? key : "\(fullKey).\(key)"

//                if let setter = try setterFor(propertyFullKey: propertyFullKey, value: value, rootKtv: rootKtv) {
//                    return "        object.\(key) = " + setter
//                }
//
//                return nil
            }

            let propertySetters: String = applyedProperties.reduce("") {
                if $0.isEmpty {
                    return $1
                } else {
                    return $0 + "\n" + $1
                }
            }

            return "\n" +
                   "    public mutating func apply(\(type) object: \(type)) {\n" +
                            propertySetters + "\n" +
                   "    }\n"
        }

        return ""
    }

    func setterFor(propertyFullKey propertyFullKey: String, value: KTVValue, rootKtv: KTVObject) throws -> String? {
        var setter:String? = nil

        switch value {
            case .nilValue:
                setter = "nil"
            case .bool(_):
                setter = "self.bool(\"\(propertyFullKey)\")"
            case .string(_):
                setter = "self.string(\"\(propertyFullKey)\")"
            case .int(_):
                setter = "self.int(\"\(propertyFullKey)\")"
            case .double(_):
                setter = "self.double(\"\(propertyFullKey)\")"

            case .color(_):
                setter = "self.color(\"\(propertyFullKey)\")"

            case .reference(let referenceKey):
                let value = try rootKtv.findObjectByReference(referenceKey)
                let referenceKeyWithoutAt = referenceKey.stringByReplacingOccurrencesOfString("@", withString: "")
                setter = try setterFor(propertyFullKey: referenceKeyWithoutAt, value: value, rootKtv: rootKtv)

            case .object(let type, _):
                if type == "font" {
                    setter = "self.font(\"\(propertyFullKey)\")"
                } else if type == "textAttributes" {
                    setter = "self.textAttributes(\"\(propertyFullKey)\")"
                } else {
                    //ToDo: exception? error?
                }

            case .array(let type, _):
                if type == "point" {
                    setter = "self.point(\"\(propertyFullKey)\")"
                } else if type == "rect" {
                    setter = "self.rect(\"\(propertyFullKey)\")"
                } else if type == "insets" {
                    setter = "self.edgeInsets(\"\(propertyFullKey)\")"
                } else {
                    //ToDo: exception? error?
                }
        }

        return setter
    }
}