//
// Created by Alexander Babaev on 15/06/2016.
// Copyright (c) 2016 LonelyBytes. All rights reserved.
//

import Foundation

private extension String {
    func capitalizeFirstLetter() -> String {
        if isEmpty {
            return self
        } else {
            return substringToIndex(startIndex.successor()).uppercaseString + substringFromIndex(startIndex.successor())
        }
    }
}

class S2GeneratorSwiftNew: S2Generator {
    func generateToFile(path: String, fromObject: KTVObject, rootClassName: String, needS2Import: Bool, needSingleton: Bool) throws {
        let classProperties = try objectPropertyFor(name:rootClassName, type: "", object: fromObject, fullKey: "", rootKtv: fromObject)

        let file =
                "// AUTOGENERATED FILE\n" +
                "// Do not edit manually please\n" +
                "\n" +
                "import Foundation\n" +
                "import UIKit\n" +
                "import S2Kit\n" +
                "\n\n" +
                classProperties

        try file.writeToFile(path, atomically:true, encoding:NSUTF8StringEncoding)

//        var fileString = fileHeader(rootClassName, needS2Import:needS2Import, needSingleton:needSingleton)
//        let (structString, _) = try getStructForObject(ktv, className:rootClassName, isRootClass:true, usingSingleton:needSingleton)
//        fileString += structString
//
//        try fileString.writeToFile(path, atomically:true, encoding:NSUTF8StringEncoding)
//
//        ktv = KTVObject()
//        _usedClassNamesForObjC = []
    }

    func propertyFor(name name: String, value: KTVValue, fullKey: String, rootKtv: KTVObject) throws -> String {
        var result = ""

        NSLog("%@", fullKey)

        switch value {
            case .nilValue:
                result = "lazy var \(name):AnyObject? = nil"
            case .bool(_):
                result = "lazy var \(name):Bool = self.bool(\"\(fullKey)\")"
            case .string(_):
                result = "lazy var \(name):String = self.string(\"\(fullKey)\")"
            case .int(_):
                result = "lazy var \(name):Int = self.int(\"\(fullKey)\")"
            case .double(_):
                result = "lazy var \(name):Double = self.double(\"\(fullKey)\")"

            case .color(_):
                result = "lazy var \(name):UIColor = self.color(\"\(fullKey)\")"

            case .reference(let referenceKey):
                let value = try rootKtv.findObjectByReference(referenceKey)
                result = try propertyFor(name: name, value: value, fullKey: fullKey, rootKtv: rootKtv)

            case .object(let type, let object):
                if type == "font" {
                    result = "lazy var \(name):UIFont = self.font(\"\(fullKey)\")"
                } else if type == "textAttributes" {
                    result = "lazy var \(name):[String:AnyObject] = self.textAttributes(\"\(fullKey)\")"
                } else {
                    let classDefinition = try objectPropertyFor(name: name, type: type, object: object, fullKey: fullKey, rootKtv: rootKtv)
                    let className = name.capitalizeFirstLetter()
                    result = "\nlazy var \(name):\(className) = \(className)(ktv:self.ktv)\n\(classDefinition)\n"
                }

            case .array(let type, _):
                if type == "point" {
                    result = "lazy var \(name):CGPoint = self.point(\"\(fullKey)\")"
                } else if type == "rect" {
                    result = "lazy var \(name):CGRect = self.rect(\"\(fullKey)\")"
                } else if type == "insets" {
                    result = "lazy var \(name):UIEdgeInsets = self.edgeInsets(\"\(fullKey)\")"
                } else {
                    throw S2GeneratorErrors.UnsupportedValueType
                }

//            default:
//                throw S2GeneratorErrors.UnknownValueType
        }

        return result
    }

    func objectPropertyFor(name name: String, type: String, object: KTVObject, fullKey: String, rootKtv: KTVObject) throws -> String {
        let properties = try object.properties.map {
            (key: String, value: KTVValue) -> String in

            let propertyFullKey = fullKey.isEmpty ? key : "\(fullKey).\(key)"

            return try self.propertyFor(name: key, value: value, fullKey: propertyFullKey, rootKtv: rootKtv).stringByReplacingOccurrencesOfString("\n", withString: "\n    ")
        }

        var propertiesString:String = properties.reduce("") {
            if $0.isEmpty {
                if $1.hasPrefix("\n") {
                    return "    " + $1.stringByReplacingOccurrencesOfString("^\\s+", withString:"", options:[.RegularExpressionSearch], range:nil)
                } else {
                    return "    " + $1
                }
            } else {
                return $0 + "\n    " + $1
            }
        }

        if propertiesString.hasSuffix("\n    ") {
            propertiesString = propertiesString.stringByReplacingOccurrencesOfString("\\s+$", withString:"", options:[.RegularExpressionSearch], range:nil)
        }

        return "public struct \(name.capitalizeFirstLetter()): StyleObject {\n" +
                    propertiesString + "\n" +
               "    public let ktv:KTVObject\n" +
               "    init(ktv:KTVObject) { self.ktv = ktv }\n" +
               "}"
    }

    func arrayPropertyFor(name name: String, type: String, arrayValues: KTVObject, fullKey: String, rootKtv: KTVObject) throws -> String {
        return ""
    }
}